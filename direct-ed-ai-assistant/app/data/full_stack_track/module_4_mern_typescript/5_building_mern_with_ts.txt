Title: Building a MERN App with TypeScript

---
## Part 1: The Power of a Type-Safe Full Stack
---

Building a **MERN (MongoDB, Express, React, Node.js)** application with **TypeScript** combines the flexibility of the MERN stack with the robustness and safety of static typing. This creates a highly efficient and maintainable development workflow where your front-end and back-end can share a common, type-safe language.

* **Analogy: Building with Precision-Engineered Parts ⚙️**
    If a standard MERN app is like building with high-quality, but generic, parts, then adding TypeScript is like using **precision-engineered, CAD-designed parts**. Every connection point is perfectly measured and defined. A front-end component expecting a `user` object with an `email` string can't be accidentally connected to a back-end endpoint that sends a `user` object with an `e-mail` string. The compiler catches this mismatch instantly, preventing runtime errors and making the entire system more reliable.

### **Key Advantages:**
* **End-to-End Type Safety:** You can share type definitions between your React front-end and your Express back-end, ensuring that the data being sent and received is always consistent.
* **Fewer Bugs:** Catches common errors related to data shapes and API contracts at compile time.
* **Enhanced Developer Experience:** Enjoy superior autocompletion and code intelligence across your entire stack.
* **Easier Refactoring:** Confidently make changes to your data models, knowing that TypeScript will flag every part of your application that needs to be updated.

---
## Part 2: Project Setup (Monorepo Structure)
---

For a MERN project, it's best practice to use a **monorepo** structure, where both the front-end and back-end code live in the same parent repository.

1.  **Create the root project folder:**
    ```bash
    mkdir mern-ts-app
    cd mern-ts-app
    ```
2.  **Initialize the root `package.json`:** This will help manage both projects.
    ```bash
    npm init -y
    ```
3.  **Create folders for the server and client:**
    ```bash
    mkdir server client
    ```
Your folder structure will look like this:
/mern-ts-app
├── /client
├── /server
└── package.json

---
## Part 3: Building the Back-End (Server)
---

Let's build the Express API first.

1.  **Navigate to the server directory and initialize its own `package.json`:**
    ```bash
    cd server
    npm init -y
    ```
2.  **Install dependencies:**
    ```bash
    # Production dependencies
    npm install express mongoose dotenv cors

    # Development dependencies (TypeScript and type definitions)
    npm install typescript ts-node-dev @types/express @types/node @types/cors --save-dev
    ```
3.  **Create a `tsconfig.json` file:**
    ```bash
    npx tsc --init
    ```
    Now, configure your `tsconfig.json` for a Node.js project. Key settings include:
    ```json
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "CommonJS",
        "rootDir": "./src",
        "outDir": "./dist",
        "esModuleInterop": true,
        "strict": true
      }
    }
    ```
4.  **Create your source folder and server entry point:**
    ```bash
    mkdir src
    touch src/server.ts
    ```
5.  **Write the basic Express server code in `src/server.ts`:**
    ```typescript
    import express, { Request, Response } from 'express';
    import cors from 'cors';
    import mongoose from 'mongoose';
    import dotenv from 'dotenv';

    dotenv.config();

    const app = express();
    const PORT = process.env.PORT || 5000;

    // --- Middleware ---
    app.use(cors()); // Enable Cross-Origin Resource Sharing
    app.use(express.json()); // Enable JSON body parsing

    // --- Mongoose Connection (Example) ---
    // mongoose.connect(process.env.MONGO_URI!)
    //   .then(() => console.log('MongoDB connected'))
    //   .catch(err => console.error(err));

    // --- API Routes (Example Todo Model) ---
    
    // Define a shared interface for our Todo
    interface ITodo {
      text: string;
      isCompleted: boolean;
    }

    // This would typically be a Mongoose model, but we'll use an in-memory array for simplicity.
    let todos: ITodo[] = [];

    app.get('/api/todos', (req: Request, res: Response) => {
      res.json(todos);
    });

    app.post('/api/todos', (req: Request, res: Response) => {
      const newTodo: ITodo = {
        text: req.body.text,
        isCompleted: false
      };
      todos.push(newTodo);
      res.status(201).json(newTodo);
    });


    // --- Start Server ---
    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}`);
    });
    ```
6.  **Add a `dev` script to your `server/package.json`:**
    ```json
    "scripts": {
      "dev": "ts-node-dev --respawn --transpile-only src/server.ts"
    }
    ```
7.  **Start the server:**
    ```bash
    npm run dev
    ```
Your back-end API is now running on `http://localhost:5000`.

---
## Part 4: Building the Front-End (Client)
---

Now, let's create the React front-end.

1.  **Navigate back to the root directory and create the React app inside the `client` folder:**
    ```bash
    cd .. 
    npm create vite@latest client -- --template react-ts
    ```
2.  **Navigate into the new client directory and install dependencies:**
    ```bash
    cd client
    npm install
    ```
3.  **Create a shared types file:** To ensure consistency, let's define our `ITodo` interface here as well. In a real app, you'd have a shared workspace.
    `src/types.ts`
    ```typescript
    export interface ITodo {
      text: string;
      isCompleted: boolean;
    }
    ```
4.  **Build the React components (`src/App.tsx`):**
    ```tsx
    import React, { useState, useEffect } from 'react';
    import { ITodo } from './types'; // Import the shared type

    const API_URL = 'http://localhost:5000/api/todos';

    function App() {
      const [todos, setTodos] = useState<ITodo[]>([]);
      const [newTodoText, setNewTodoText] = useState('');

      // Fetch todos from the API on component mount
      useEffect(() => {
        fetch(API_URL)
          .then(res => res.json())
          .then((data: ITodo[]) => setTodos(data));
      }, []);

      const handleAddTodo = (e: React.FormEvent) => {
        e.preventDefault();
        if (!newTodoText.trim()) return;

        fetch(API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ text: newTodoText }),
        })
        .then(res => res.json())
        .then((newTodo: ITodo) => {
          setTodos([...todos, newTodo]);
          setNewTodoText('');
        });
      };

      return (
        <div>
          <h1>MERN + TypeScript Todo List</h1>
          <form onSubmit={handleAddTodo}>
            <input
              type="text"
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new todo"
            />
            <button type="submit">Add</button>
          </form>
          <ul>
            {todos.map((todo, index) => (
              <li key={index}>
                {todo.text}
              </li>
            ))}
          </ul>
        </div>
      );
    }

    export default App;
    ```
5.  **Start the client development server:**
    ```bash
    npm run dev
    ```
Your React application is now running (likely on `http://localhost:5173`) and is communicating with your Express back-end. The `cors` middleware on the server is what allows the client (on a different port) to make requests to the server without being blocked by browser security policies.
